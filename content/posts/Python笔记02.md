---
date: 2024-12-27T09:03:44+08:00
description: ""
image: ""
lastmod: 2024-12-27
showTableOfContents: true
tags: ["Python","笔记"]
title: "Python笔记02"
type: "post"
---
# 流程控制
## if-else 
Python 中的 if else 语句可以细分为三种形式，分别是 if 语句、if else 语句和 if elif else 语句
对语法格式的说明：
- “表达式”可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句，形式不限，只要它能得到一个值就行。不管“表达式”的结果是什么类型，if else 都能判断它是否成立（真或者假）。
- “代码块”由具由相同缩进量的若干条语句组成。
- if、elif、else 语句的最后都有冒号`:`，不要忘记。
```python
age = int( input("请输入你的年龄：") )

if age < 18 :
    print("你还未成年，建议在家人陪同下使用该软件！")
    print("如果你已经得到了家长的同意，请忽略以上提示。")

#该语句不属于if的代码块
print("软件正在使用中...")
```
### 判断表达式是否成立
if 和 elif 后面的“表达式”的形式是很自由的，只要表达式有一个结果，不管这个结果是什么类型，Python 都能判断它是“真”还是“假”。
### 对缩进的要求
pyhton是以缩进来标记代码块的，代码块一定要有缩进，没有缩进的不是代码块。另外，同一个代码块的缩进量要相同，缩进量不同的不属于同一个代码块。
## pass语句及其作用
 Python 提供了一种更加专业的做法，就是空语句 pass。**pass** 是 Python 中的关键字，用来让解释器跳过此处，什么都不做。
## assert断言函数及用法
assert 语句，又称断言语句，可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。
## while循环
while 循环和 if 条件分支语句类似，即在条件（表达式）为真的情况下，会执行相应的代码块。不同之处在于，只要条件为真，while 就会一直重复执行那段代码块。
## for循环
它常用于遍历字符串、列表、元组、字典、集合等序列类型，逐个获取序列中的各个元素。  
for 循环的语法格式如下：  
for 迭代变量 in 字符串|列表|元组|字典|集合：  
    代码块
格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。
## else用法
无论是 while 循环还是 for 循环，其后都可以紧跟着一个 else 代码块，它的作用是当循环条件为 False 跳出循环时，程序会最先执行 else 代码块中的代码。
## 循环嵌套
支持 if 语句相互嵌套，while 和 for 循环结构也支持嵌套。所谓嵌套（Nest），就是一条语句里面还有另一条语句，例如 for 里面还有 for，while 里面还有 while，甚至 while 中有 for 或者 for 中有 while 也都是允许的。  
当 2 个（甚至多个）循环结构相互嵌套时，位于外层的循环结构常简称为外层循环或外循环，位于内层的循环结构常简称为内层循环或内循环。  
循环嵌套结构的代码，Python 解释器执行的流程为：
1. 当外层循环条件为 True 时，则执行外层循环结构中的循环体；
2. 外层循环体中包含了普通程序和内循环，当内层循环的循环条件为 True 时会执行此循环中的循环体，直到内层循环条件为 False，跳出内循环；
3. 如果此时外层循环的条件仍为 True，则返回第 2 步，继续执行外层循环体，直到外层循环的循环条件为 False；
4. 当内层循环的循环条件为 False，且外层循环的循环条件也为 False，则整个嵌套循环才算执行完毕。
## break
break 语句可以立即终止当前循环的执行，跳出当前所在的循环结构。无论是 while 循环还是 for 循环，只要执行 break 语句，就会直接结束当前正在执行的循环体。
## continue的用法
continue 语句的作用则没有那么强大，它只会终止执行本次循环中剩下的代码，直接从下一次循环继续执行。

# 函数
Python 提供了一个功能，即允许我们将常用的代码以固定的格式封装（包装）成一个独立的模块，只要知道这个模块的名字就可以重复使用它，这个模块就叫做函数（Function）。
函数的本质就是一段有特定功能、可以重复使用的代码
## 函数的定义
也就是创建一个函数，可以理解为创建一个具有某些用途的工具。定义函数需要用 def 关键字实现，具体的语法格式如下：
```python
def 函数名(参数列表):  
    //实现特定功能的多行代码  
    [return [返回值]]
```
其中，用 [] 括起来的为可选择部分，即可以使用，也可以省略。  
此格式中，各部分参数的含义如下：  
- 函数名：其实就是一个符合 Python 语法的标识符，但不建议读者使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能（如上面的 my_len，即表示我们自定义的 len() 函数）。
- 形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔。
- [return [返回值] ]：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。
## 函数的调用
调用函数也就是执行函数。如果把创建的函数理解为一个具有某种用途的工具，那么调用函数就相当于使用该工具。  
函数调用的基本语法格式如下所示：
`[返回值] = 函数名([形参值])`
其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。
##  函数值传递和引用传递（包括形式参数和实际参数的区别）
通常情况下，定义函数时都会选择有参数的函数形式，函数参数的作用是传递数据给函数，令其对接收的数据做具体的操作处理。  
在使用函数时，经常会用到形式参数（简称“形参”）和实际参数（简称“实参”），二者都叫参数，之间的区别是：  
- 形式参数：在定义函数时，函数名后面括号中的参数就是形式参数，例如:
```python
#定义函数时，这里的函数参数 obj 就是形式参数
def demo(obj)
  print(obj)
```
- 实际参数：在调用函数时，函数名后面括号中的参数称为实际参数，也就是函数的调用者给函数的参数。例如:
```python
a = "helloworld"
demo(a)
```
实参和形参的区别，就如同剧本选主角，剧本中的角色相当于形参，而演角色的演员就相当于实参。
想一个问题，那就是实参是如何传递给形参的呢？
根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：
1. 值传递：适用于实参类型为不可变类型（字符串、数字、元组）；
2. 引用（地址）传递：适用于实参类型为可变类型（列表，字典）；
值传递和引用传递的区别是，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。
## 函数默认参数
在调用函数时如果不指定某个参数，Python 解释器会抛出异常。为了解决这个问题，Python 允许为参数设置默认值，即在定义函数时，直接给形式参数指定一个默认值。这样的话，即便调用函数时没有给拥有默认值的形参传递参数，该参数可以直接使用定义函数时设置的默认值。  
Python 定义带有默认值参数的函数，其语法格式如下：
def 函数名(...，形参名，形参名=默认值)：  
    代码块
注意，在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。
# 变量作用域（全局变量和局部变量）
所谓作用域（Scope），就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在整段代码的任意位置使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。  
变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。本节我们只讲解两种变量，局部变量和全局变量。
## 局部变量
在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。  
要知道，当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。
## 全局变量
Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。  
和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。
### 定义全局变量的方法
在函数体外定义的变量，一定是全局变量。
在函数体内定义全局变量。即使用 global 关键字对变量进行修饰后，该变量就会变为全局变量。
# lambda表达式（匿名函数）及用法
lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。  
lambda 表达式的语法格式如下：  
`name = lambda [list] : 表达式`
	其中，定义 lambda 表达式，必须使用 lambda 关键字`[list]` 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。
可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。相比函数，lamba 表达式具有以下  2 个优势：  
- 对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；
- 对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。
# 类和对象
面向对象中，常用术语包括：
- 类：可以理解是一个模板，通过它可以创建出无数个具体实例。比如，前面编写的 tortoise 表示的只是乌龟这个物种，通过它可以创建出无数个实例来代表各种不同特征的乌龟（这一过程又称为类的实例化）。
- 对象：类并不能直接使用，通过类创建出的实例（又称对象）才能使用。这有点像汽车图纸和汽车的关系，图纸本身（类）并不能为人们使用，通过图纸创建出的一辆辆车（对象）才能使用。
- 属性：类中的所有变量称为属性。例如，tortoise 这个类中，bodyColor、footNum、weight、hasShell 都是这个类拥有的属性。
- 方法：类中的所有函数通常称为方法。不过，和函数所有不同的是，类方法至少要包含一个 self 参数（后续会做详细介绍）。例如，tortoise 类中，crawl()、eat()、sleep()、protect() 都是这个类所拥有的方法，类方法无法单独使用，只能和类的对象一起使用。
## 类
程序中类的使用顺序是这样的：
1. 创建（定义）类，也就是制作图纸的过程；
2. 创建类的实例对象（根据图纸造出实际的物品），通过实例对象实现特定的功能。
### 定义
Python 中定义一个类使用 class 关键字实现，其基本语法格式如下：  
class 类名：  
    多个（≥0）类属性...  
    多个（≥0）类方法...
 类属性指的就是包含在类中的变量；而类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。需要注意的一点是，同属一个类的所有类属性和类方法，要保持统一的缩进格式，通常统一缩进 4 个空格。
###  `__init__()`类构造方法
 在创建类时，我们可以手动添加一个 __init__() 方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。  
构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。Python 类中，手动添加构造方法的语法格式如下：
```python
def __init__(self,...):  
    代码块
```
## 类对象的创建和使用
创建类对象的过程，又称为类的实例化。
对已定义好的类进行实例化，其语法格式如下：
类名(参数)
定义类时，如果没有手动添加 `__init__() `构造方法，又或者添加的` __init__()` 中仅有一个 self 参数，则创建类对象时的参数可以省略不写。
### 使用
定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：
- 访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；
- 调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。
### 类对象访问变量或方法
使用已创建好的类对象访问类中实例变量的语法格式如下：
类对象名.变量名
使用类对象调用类中方法的语法格式如下：
对象名.方法名(参数)
注意，对象名和变量名以及方法名之间用点 "." 连接。
### self用法详解
定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。
总之，无论是类中的构造函数还是普通的类方法，实际调用它们的谁，则第一个参数 self 就代表谁。
### 类变量和实例变量（类属性和实例属性）
在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：
1. 类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；
2. 类体中，所有函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；
3. 类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。
### property()函数：定义属性
为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个 getter（或 setter）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性
Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。  
property() 函数的基本使用格式如下：
`属性名=property(fget=None, fset=None, fdel=None, doc=None)`
get 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。
# 继承
Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。
子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：  
```python
class 类名(父类1, 父类2, ...)：  
#类定义部分
```
## 父类方法重写
我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。
##  super()函数：调用父类的构造方法
在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：
1. 类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；
2. 使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。
# 多态
类的多态特性，还要满足以下 2 个前提条件：
1. 继承：多态一定是发生在子类和父类之间；
2. 重写：子类重写了父类的方法。
Python 这种由多态衍生出的更灵活的编程机制，又称为“鸭子模型”或“鸭子类型”。

# 类特殊成员（属性和方法）
凡是以双下划线 `__`开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法）。

# 异常处理
Python 也提供了处理异常的机制，可以让我们捕获并处理这些错误，让程序继续沿着一条不会出错的路径执行。
用`try except`语句块捕获并处理异常，其基本语法结构如下所示：
```python
try:  
    可能产生异常的代码块  
except [ (Error1, Error2, ... ) [as e] ]:  
    处理异常的代码块1  
except [ (Error3, Error4, ... ) [as e] ]:  
    处理异常的代码块2  
except  [Exception]:  
    处理其它异常
```
从`try except`的基本语法格式可以看出，try 块有且仅有一个，但 except 代码块可以有多个，且每个 except 块都可以同时处理多种异常。
try except 语句的执行流程如下：

1. 首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。
2. 当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。
在原本的`try except`结构的基础上，Python 异常处理机制还提供了一个 else 块，也就是原有 try except 语句的基础上再添加一个 else 块，即`try except else`结构。  
使用 else 包裹的代码，只有当 try 块没有捕获到任何异常时，才会得到执行；反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。
### 资源回收
异常处理机制还提供了一个 finally 语句，通常用来为 try 块中的程序做扫尾清理工作
和 else 语句不同，finally 只要求和 try 搭配使用，而至于该结构中是否包含 except 以及 else，对于 finally 不是必须的（else 必须和 try except 搭配使用）。
在整个异常处理机制中，finally 语句的功能是：无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块。
### raise用法
python允许我们在程序中手动设置异常，使用 raise 语句即可。
aise 语句的基本语法格式为：  
`raise [exceptionName [(reason)]]`
其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。
